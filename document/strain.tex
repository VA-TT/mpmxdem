\documentclass[12pt]{article}
% -------------------------------------------------
% paquets
% -------------------------------------------------
\usepackage[utf8x]{inputenc}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{empheq}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{oldgerm}
\usepackage{amsthm}
\usepackage{epsfig,graphicx,color}
\usepackage{verbatim,listings}
\usepackage{geometry}
\usepackage{relsize}
\usepackage{afterpage}
\usepackage{mathrsfs} % \mathscr{O} better than \boldsymbol{O}
\usepackage{dsfont}
\usepackage{pstricks-add}
\usepackage{cite}
% -------------------------------------------------
% macros perso
% -------------------------------------------------
\geometry{a4paper,total={190mm,257mm},left=15mm,top=15mm,right=15mm,bottom=20mm}
\setlength{\parindent}{0em}
\setlength{\parskip}{0.5em}
\sloppy
\newcommand{\Red}[1]  {{\color[rgb]{1,0,0}{{#1}}}}
\newcommand{\Blue}[1] {{\color[rgb]{0,0.5,0.7}{{#1}}}}
\newcommand{\Darkblue}[1] {{\color[rgb]{0,0,1}{{#1}}}}
\renewcommand{\leq}   {\leqslant} % plus joli
\renewcommand{\le}    {\leqslant}
\renewcommand{\geq}   {\geqslant}
\renewcommand{\ge}    {\geqslant}
\newcommand{\argmin}  {\mathop{\rm arg\,min}}
\begin{document}
Ce document a pour but d'étendre la méthode MPM avec un schéma en temps de type \emph{modified lagragian} présentée page 19 
de \cite{Gra-2018} au cas d'un tenseur de Cauchy déduit par homogénisation numérique à la place d'une équation constitutive
de type élastoplastique.
Notons $\boldsymbol X$ la configuration initiale et $\boldsymbol x(t)$ la configuration déformée de sorte que le tenseur de déformation se note
$\boldsymbol F(t)=\boldsymbol\nabla_X(x(t))$. Introduisons aussi le tenseur de Cauchy-green à droite 
$\boldsymbol C=\boldsymbol F^T\boldsymbol F$ et le tenseur matériel $\boldsymbol E=1/2(\boldsymbol C- \boldsymbol I)$.
On note aussi la vitesse dans la configuration déformée $\boldsymbol v=\partial_t x$ 
et son gradient $\boldsymbol l=\nabla_x\boldsymbol v$. 
Les différents arguments de cinématiques donnée sont tirés du chapitre 4 de \cite{BonWoo-2008}.

\section{Modification de l'algo}
L'algo de MPM est incrémental, c'est à dire qu'à chaque pas de temps un problème en petites déformation est résolu, cela sera conservé. 

La modification concerne les \emph{points 12 et 13}. En effet, dans le cadre les modèles constitutifs élastoplastiques sont
définis en fonction de le taux de déformation linéarisé associé au tenseur matériel 
$\boldsymbol{\dot\varepsilon}=1/2(\nabla \boldsymbol v+\nabla \boldsymbol v^T)$. En conséquence, l'incrément de déformation utilisé
dans le cas élastoplastique est $\Delta \boldsymbol \varepsilon=\Delta t/2(\boldsymbol l+\boldsymbol l^T)$ pour calculer la contrainte au temps
$t+\Delta t$, ce calcul est effectué dans la configuration $x$.

En revanche, l'utilisation d'une simulation DEM pour trouver le tenseur de constrainte de Cauchy $\boldsymbol \sigma$ est necessite l'application
du taux de déformation linéarisé associé au tenseur de déformation, gradient de vitesse $\boldsymbol l$ dans la configuration $x$. 
Chaque point matériel étant  un échantillon tri periodiques déformés par $\Delta t\boldsymbol l$ pendant une durée $\Delta t$.
Sachant que le taux de déformation exprimé dans la confguration de $X$ vaut $\boldsymbol{\dot F}=\boldsymbol l\boldsymbol F$, 
l'incrément de la déformation totale s'exprime comme $\Delta \boldsymbol F=\Delta t\boldsymbol l \boldsymbol F$. 
Dans le code MPM, $\boldsymbol F(t)$ est défini comme {\texttt MaterialPoint::prev\_F} et 
$\boldsymbol F(t+\Delta t)=\boldsymbol F+ \Delta F$ est défini comme {\texttt MaterialPoint::F}.
\begin{itemize}
\item
Le point 12 est donc remplacé l'utilisation de la fonction : 
\begin{verbatim}
void MPMbox::updateTransformationGradient() {
  int* I;
  for (size_t p = 0; p < MP.size(); p++) {
    I = &(Elem[MP[p].e].I[0]);
    MP[p].velGrad.reset();
    for (int r = 0; r < element::nbNodes; r++) {
      MP[p].velGrad.xx += (MP[p].gradN[r].x * nodes[I[r]].vel.x);
      MP[p].velGrad.yy += (MP[p].gradN[r].y * nodes[I[r]].vel.y);
      MP[p].velGrad.xy += (MP[p].gradN[r].y * nodes[I[r]].vel.x);
      MP[p].velGrad.yx += (MP[p].gradN[r].x * nodes[I[r]].vel.y);
    }
    MP[p].prev_F = MP[p].F;
    MP[p].F = (mat4::unit() + dt * MP[p].velGrad) * MP[p].F;
  }
}
\end{verbatim}
Le code DEM contient la fonction
\begin{verbatim}
void PBC3Dbox::transform(mat9r& Finc, double macro_dt) {
  double dtc = sqrt(Vmin * density / kn);
  dt = dtc * 0.1;
  if (dt >= macro_dt) dt = macro_dt * 0.2;
  dt_2 = 0.5 * dt;
  dt2_2 = 0.5 * dt * dt;
  tmax = t + macro_dt;
  interVerlet = 100 * dt; // on peut faire une meilleur estimation
  mat9r dFmI = Finc;
  dFmI.xx -= 1.0;
  dFmI.yy -= 1.0;
  dFmI.zz -= 1.0;
  mat9r vh = (1.0 / macro_dt) * (dFmI * Cell.h);
  Load.VelocityControl(vh);
  updateNeighborList(dVerlet);
  while (t < tmax) {
    velocityVerletStep();
    if (interVerletC >= interVerlet) {
      updateNeighborList(dVerlet);
      interVerletC = 0.0;
    }
    interVerletC += dt;
    t += dt;
  }
}
\end{verbatim} 
Cette fonction prend en entrée {\texttt Finc} qu'il faut comprendre comme $\boldsymbol I+\Delta t \boldsymbol l$.
C'est à dire l'incrément au sens de la composition, pas de l'addition dans le code DEM, on est en grandes déformations.
\item
Le point 13 est donc remplacé par un appel à la fonction 
\begin{verbatim} 
void hnlDEM::updateStrainAndStress(MPMbox& MPM, size_t p) {
  mat4 prev_F_inv = MPM.MP[p].prev_F;
  prev_F_inv.inverse();
  mat4 Finc2D = MPM.MP[p].F*prev_F_inv;
  mat9r Finc3D;
  Finc3D.xx = Finc2D.xx;
  Finc3D.xy = Finc2D.xy;
  Finc3D.yx = Finc2D.yx;
  Finc3D.yy = Finc2D.yy;
  Finc3D.zz = 1.0;
  MPM.MP[p].PBC->transform(Finc3D, MPM.dt);
  char fname[256];
  sprintf(fname, "%s/conf_MP%zu", MPM.result_folder.c_str(), p);
  MPM.MP[p].PBC->saveConf(fname);
  MPM.MP[p].stress.xx = -MPM.MP[p].PBC->Sig.xx;
  MPM.MP[p].stress.xy = -MPM.MP[p].PBC->Sig.xy;
  MPM.MP[p].stress.yx = -MPM.MP[p].PBC->Sig.yx;
  MPM.MP[p].stress.yy = -MPM.MP[p].PBC->Sig.yy;
}
\end{verbatim}
\end{itemize}
\bibliographystyle{alpha}
\bibliography{strain}
\end{document}
